{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "AAAO7eKuK7eQ"
   },
   "outputs": [],
   "source": [
    "# TODO remove this before merging\n",
    "![[ -v COLAB_GPU ]] &&  !pip install -q https://github.com/pyro-ppl/pyro/archive/workflow-tutorial.zip\n",
    "#![[ -v COLAB_GPU ]] && pip install -q git+https://github.com/pyro-ppl/pyro.git@workflow-tutorial"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "llE7btqvKM3m"
   },
   "source": [
    "# High-dimensional Bayesian workflow, with applications to SARS-CoV-2 strains\n",
    "\n",
    "This tutorial describes a workflow for incrementally building pipelines to analyze high-dimensional data in Pyro. This workflow has evolved over a few years of applying Pyro to models with $10^5$ or more latent variables. We build on [Gelman et al. (2020)](https://arxiv.org/abs/2011.01808)'s concept of *Bayesian workflow*, and focus on aspects particular to high-dimensional models: approximate inference and numerical stability. While the individual components of the pipeline deserve their own tutorials, this tutorial focuses on incrementally combining those components.\n",
    "\n",
    "The fastest way to find a good model of your data is to quickly discard many bad models, i.e. to iterate.\n",
    "In statistics we call this iterative workflow [Box's loop](http://www.cs.columbia.edu/~blei/papers/Blei2014b.pdf).\n",
    "An efficient workflow allows us to discard bad models as fast as possible.\n",
    "Workflow efficiency demands that code changes to upstream components don't break previous coding effort on downstream components.\n",
    "Pyro's approaches to this challenge include strategies for variational approximations ([pyro.infer.autoguide](https://docs.pyro.ai/en/stable/infer.autoguide.html)) and strategies for transforming model coordinate systems to improve geometry ([pyro.infer.reparam](https://docs.pyro.ai/en/stable/infer.reparam.html)).\n",
    "\n",
    "#### Summary\n",
    "\n",
    "- Great models can only be achieved by iterative development.\n",
    "- Iterate quickly by building a pipeline that is robust to code changes.\n",
    "- Start with a simple model and [mean-field inference](https://docs.pyro.ai/en/dev/infer.autoguide.html#autonormal).\n",
    "- Avoid NANs by intellitently [initializing](https://docs.pyro.ai/en/dev/infer.autoguide.html#module-pyro.infer.autoguide.initialization) and [.clamp()](https://pytorch.org/docs/stable/generated/torch.clamp.html)ing.\n",
    "- [Reparametrize](https://docs.pyro.ai/en/dev/infer.reparam.html) the model to improve geometry.\n",
    "- Create a custom variational family by combining [AutoGuides](https://docs.pyro.ai/en/dev/infer.autoguide.html) or [EasyGuides](https://docs.pyro.ai/en/dev/contrib.easyguide.html).\n",
    "\n",
    "#### Table of contents\n",
    "- [Overview](#Overview)\n",
    "- [Running example: SARS-CoV-2 strain prediction](#Running-example)\n",
    "1. [Clean the data](#Clean-the-data)\n",
    "2. [Create a generative model](#Create-a-generative-model)\n",
    "3. [Sanity check using mean-field inference](#Sanity-check)\n",
    "4. [Create an initialization heuristic](#Create-an-initialization-heuristic)\n",
    "5. [Reparametrize the model](#Reparametrize)\n",
    "6. [Customize the variational family (autoguides, easyguides, custom guides](#Customize)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "1Sj_aC_4KM3p"
   },
   "source": [
    "## Overview <a name=\"Overview\" />\n",
    "\n",
    "Consider the problem of sampling from the posterior distribution of a probabilistic model with $10^5$ or more continuous latent variables, but whose data fits entirely in memory.\n",
    "(For larger datasets, consider [amortized variational inference](http://pyro.ai/examples/svi_part_ii.html).) Inference in such high-dimensional models can be challenging even when posteriors are known to be [unimodal](https://en.wikipedia.org/wiki/Unimodality) or even [log-concave](https://arxiv.org/abs/1404.5886), due to correlations among latent variables.\n",
    "\n",
    "To perform inference in such high-dimensional models in Pyro, we have evolved a [workflow](https://arxiv.org/abs/2011.01808) to incrementally build data analysis pipelines combining variational inference, MCMC, reparametrization effects, and ad-hoc initialization strategies. Our workflow is summarized as a sequence of steps, where validation after any step might suggest backtracking to change design decisions at a previous step.\n",
    "\n",
    "1. Clean the data.\n",
    "2. Create a generative model.\n",
    "3. Sanity check using MAP or mean-field inference.\n",
    "4. Create an initialization heuristic.\n",
    "5. Reparameterize the model, evaluating results under mean field VI.\n",
    "6. Customize the variational family (autoguides, easyguides, custom guides).\n",
    "\n",
    "The crux of efficient workflow is to ensure changes don't break your pipeline. That is, after you build a number of pipeline stages, validate results, and decide to change one component in the pipeline, you'd like to minimize code changes needed in other components. The remainder of this tutorial describes these steps individually, then describes nuances of interactions among stages, then provides an example."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Running example: SARS-CoV-2 strain prediction <a name=\"Running-example\" />\n",
    "\n",
    "The running example in this tutorial will be a model [(Obermeyer et al. 2021)](https://www.medrxiv.org/content/10.1101/2021.09.07.21263228v1) of the relative growth rates of different strains of the SARS-CoV-2 virus, based on [open data](https://docs.nextstrain.org/projects/ncov/en/latest/reference/remote_inputs.html) counting different [PANGO lineages](https://cov-lineages.org/) of samples collected at different times around the world. There are about 2 million sequences in total.\n",
    "\n",
    "The model is a high-dimensional regression model with around 1000 coefficients, a multivariate logicstic growth function (using a simple [torch.softmax()](https://pytorch.org/docs/stable/generated/torch.nn.functional.softmax.html)) and a [Multinomial](https://pytorch.org/docs/stable/distributions.html#multinomial likelihood. While the number of coefficients is relatively small, there are about 500,000 local latent variables to estimate, and plate structure in the model should lead to an approximately block diagonal covariance matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "njvgAMszKM3q"
   },
   "outputs": [],
   "source": [
    "from collections import defaultdict\n",
    "from pprint import pprint\n",
    "import functools\n",
    "import math\n",
    "import os\n",
    "import torch\n",
    "import pyro\n",
    "import pyro.distributions as dist\n",
    "import pyro.poutine as poutine\n",
    "from pyro.distributions import constraints\n",
    "from pyro.infer import SVI, Trace_ELBO\n",
    "from pyro.infer.autoguide import (\n",
    "    AutoDelta,\n",
    "    AutoNormal,\n",
    "    AutoMultivariateNormal,\n",
    "    AutoLowRankMultivariateNormal,\n",
    "    AutoGuideList,\n",
    "    init_to_feasible,\n",
    ")\n",
    "from pyro.infer.reparam import AutoReparam, LocScaleReparam\n",
    "from pyro.nn.module import PyroParam\n",
    "from pyro.optim import ClippedAdam\n",
    "from pyro.ops.special import sparse_multinomial_likelihood\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "if torch.cuda.is_available():\n",
    "    print(\"Using GPU\")\n",
    "    torch.set_default_tensor_type(\"torch.cuda.FloatTensor\")\n",
    "else:\n",
    "    print(\"Using CPU\")\n",
    "smoke_test = ('CI' in os.environ)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "j3sbFxmGKM3r"
   },
   "source": [
    "\n",
    "## Clean the data <a name=\"Clean-the-data\"/>\n",
    "\n",
    "While in principle you could be Bayesian about everything, it's best to focus probabilistic inference on the truly uncertain parts of your problem."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ZWFmW8HAKM3s"
   },
   "source": [
    "Our running example will use a pre-cleaned dataset.\n",
    "We started with Nextstrain's [ncov](https://docs.nextstrain.org/projects/ncov/en/latest/reference/remote_inputs.html) tool for preprocessing, followed by the Broad Institute's [pyro-cov](https://github.com/broadinstitute/pyro-cov/blob/master/scripts/preprocess_nextstrain.py) tool for aggregation, resulting in a dataset of SARS-CoV-2 lineages observed around the world through time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "DlWE50HCKM3s"
   },
   "outputs": [],
   "source": [
    "from pyro.contrib.examples.nextstrain import load_nextstrain_counts\n",
    "dataset = load_nextstrain_counts()\n",
    "\n",
    "def summarize(x, name=\"\"):\n",
    "    if isinstance(x, dict):\n",
    "        for k, v in sorted(x.items()):\n",
    "            summarize(v, name + \".\" + k if name else k)\n",
    "    elif isinstance(x, torch.Tensor):\n",
    "        print(f\"{name}: {type(x).__name__} of shape {tuple(x.shape)} on {x.device}\")\n",
    "    elif isinstance(x, list):\n",
    "        print(f\"{name}: {type(x).__name__} of length {len(x)}\")\n",
    "    else:\n",
    "        print(f\"{name}: {type(x).__name__}\")\n",
    "summarize(dataset)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "6euQcq4SKM3s"
   },
   "source": [
    "## Create a generative model\n",
    "\n",
    "The first step to using Pyro is creating a generative model, either a python function or a [pyro.nn.Module](https://docs.pyro.ai/en/dev/nn.html#pyro.nn.module.PyroModule). Start simple. Start with a shallow hierarchy and later add latent variables to share statistical strength. Start with a slice of your data then add a [plate]() over multiple slices. Start with simple distributions like [Normal](), [LogNormal](), [Poisson]() and [Multinomial](), then consider overdispersed versions like [StudentT](), [Gamma](), [GammaPoisson]()/[NegativeBinomial](), and [DirichletMultinomial](). Keep your model simple and readable so you can share it and get feedback from domain experts. Use [weakly informative priors](http://www.stat.columbia.edu/~gelman/presentations/weakpriorstalk.pdf)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "S3XpW4EzKM3t"
   },
   "source": [
    "We'll focus on a multivariate logistic growth model of competing SARS-CoV-2 strains, as described in [Obermeyer et al. (2021)](https://www.medrxiv.org/content/10.1101/2021.09.07.21263228v1)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "gGdvwzs9KM3t"
   },
   "outputs": [],
   "source": [
    "def model(dataset):\n",
    "    features = dataset[\"features\"]\n",
    "    counts = dataset[\"counts\"]\n",
    "    assert features.shape[0] == counts.shape[-1]\n",
    "    S, M = features.shape\n",
    "    T, P, S = counts.shape\n",
    "    time = torch.arange(float(T)) * 5.5 / dataset[\"time_step_days\"]\n",
    "    time -= time.mean()\n",
    "    strain_plate = pyro.plate(\"strain\", S, dim=-1)\n",
    "    place_plate = pyro.plate(\"place\", P, dim=-2)\n",
    "    time_plate = pyro.plate(\"time\", T, dim=-3)\n",
    "\n",
    "    # Model each region as multivariate logistic growth.\n",
    "    rate_scale = pyro.sample(\"rate_scale\", dist.LogNormal(-4, 2))\n",
    "    init_scale = pyro.sample(\"init_scale\", dist.LogNormal(0, 2))\n",
    "    with pyro.plate(\"mutation\", M, dim=-1):\n",
    "        coef = pyro.sample(\"coef\", dist.Laplace(0, 0.5))\n",
    "    with strain_plate:\n",
    "        rate_loc = pyro.deterministic(\"rate_loc\", 0.01 * coef @ features.T)\n",
    "    with place_plate, strain_plate:\n",
    "        rate = pyro.sample(\"rate\", dist.Normal(rate_loc, rate_scale))\n",
    "        init = pyro.sample(\"init\", dist.Normal(0, init_scale))\n",
    "    logits = init + rate * time[:, None, None]\n",
    "    \n",
    "    # Observe sequences via a multinomial likelihood.\n",
    "    with time_plate, place_plate:\n",
    "        pyro.sample(\n",
    "            \"obs\",\n",
    "            dist.Multinomial(logits=logits.unsqueeze(-2), validate_args=False),\n",
    "            obs=counts.unsqueeze(-2),\n",
    "        )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FSwBD5tNKM3u"
   },
   "source": [
    "The execution cost of this model is dominated by the multinomial likelihood over a large sparse count matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Hf2Qui8UKM3u"
   },
   "outputs": [],
   "source": [
    "print(\"counts has {:d} / {} nonzero elements\".format(\n",
    "    dataset['counts'].count_nonzero(), dataset['counts'].numel()\n",
    "))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "qA0ZvbCsKM3u"
   },
   "source": [
    "To speed up inference (and model iteration!) we'll replace the `pyro.sample(..., Multinomial)` likelihood with an equivalent but much cheaper `pyro.factor` statement using a helper `pyro.ops.sparse_multinomial_likelihood`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "fCbB8bN2KM3v"
   },
   "outputs": [],
   "source": [
    "def model(dataset, predict=None):\n",
    "    features = dataset[\"features\"]\n",
    "    counts = dataset[\"counts\"]\n",
    "    sparse_counts = dataset[\"sparse_counts\"]\n",
    "    assert features.shape[0] == counts.shape[-1]\n",
    "    S, M = features.shape\n",
    "    T, P, S = counts.shape\n",
    "    time = torch.arange(float(T)) * 5.5 / dataset[\"time_step_days\"]\n",
    "    time -= time.mean()\n",
    "\n",
    "    # Model each region as multivariate logistic growth.\n",
    "    rate_scale = pyro.sample(\"rate_scale\", dist.LogNormal(-4, 2))\n",
    "    init_scale = pyro.sample(\"init_scale\", dist.LogNormal(0, 2))\n",
    "    with pyro.plate(\"mutation\", M, dim=-1):\n",
    "        coef = pyro.sample(\"coef\", dist.Laplace(0, 0.5))\n",
    "    with pyro.plate(\"strain\", S, dim=-1):\n",
    "        rate_loc = pyro.deterministic(\"rate_loc\", 0.01 * coef @ features.T)\n",
    "        with pyro.plate(\"place\", P, dim=-2):\n",
    "            rate = pyro.sample(\"rate\", dist.Normal(rate_loc, rate_scale))\n",
    "            init = pyro.sample(\"init\", dist.Normal(0, init_scale))\n",
    "    if predict is not None:  # Exit early during evaluation.\n",
    "        probs = (init + rate * time[predict]).softmax(-1)\n",
    "        return probs\n",
    "    logits = (init + rate * time[:, None, None]).log_softmax(-1)\n",
    "\n",
    "    # Observe sequences via a cheap sparse multinomial likelihood.\n",
    "    t, p, s = sparse_counts[\"index\"]\n",
    "    pyro.factor(\n",
    "        \"obs\",\n",
    "        sparse_multinomial_likelihood(\n",
    "            sparse_counts[\"total\"], logits[t, p, s], sparse_counts[\"value\"]\n",
    "        )\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "UPtf7TPSKM3v"
   },
   "source": [
    "## Sanity check using mean field inference\n",
    "\n",
    "Mean field Normal inference is cheap and robust, and is a good way to sanity check your posterior point estimate, even if the posterior uncertainty is implausibly narrow. We recommend starting with an [AutoNormal](https://docs.pyro.ai/en/latest/infer.autoguide.html#autonormal) guide, and possibly setting `init_scale` to a small value like `init_scale=0.01` or `init_scale=0.001`.\n",
    "\n",
    "Note that while MAP estimating via [AutoDelta](https://docs.pyro.ai/en/latest/infer.autoguide.html#autodelta) is even cheaper and more robust than mean-field `AutoNormal`, `AutoDelta` is coordinate-system dependent and is not invariant to reparametrization. Because in our experience most models benefit from some reparameterization, we recommend `AutoNormal` over `AutoDelta` because `AutoNormal` is less sensitive to reparametrization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Uhl_-vMIKM3v"
   },
   "outputs": [],
   "source": [
    "def fit_svi(model, guide, lr=0.1, num_steps=1001, log_every=100, plot=True):\n",
    "    pyro.clear_param_store()\n",
    "    pyro.set_rng_seed(20211205)\n",
    "    if smoke_test:\n",
    "        num_steps = 2\n",
    "\n",
    "    # Measure model and guide complexity.\n",
    "    num_latents = sum(\n",
    "        site[\"value\"].numel()\n",
    "        for name, site in poutine.trace(guide).get_trace(dataset).iter_stochastic_nodes()\n",
    "        if not site[\"infer\"].get(\"is_auxiliary\")\n",
    "    )\n",
    "    num_params = sum(p.unconstrained().numel() for p in pyro.get_param_store().values())\n",
    "    print(f\"Found {num_latents} latent variables and {num_params} learnable parameters\")\n",
    "    \n",
    "    # Save gradient norms during inference.\n",
    "    series = defaultdict(list)\n",
    "    def hook(g, series):\n",
    "        series.append(torch.linalg.norm(g.reshape(-1), math.inf).item())\n",
    "    for name, value in pyro.get_param_store().named_parameters():\n",
    "        value.register_hook(\n",
    "            functools.partial(hook, series=series[name + \" grad\"])\n",
    "        )\n",
    "\n",
    "    # Train the guide.\n",
    "    optim = ClippedAdam({\"lr\": lr, \"lrd\": 0.1 ** (1 / num_steps)})\n",
    "    svi = SVI(model, guide, optim, Trace_ELBO())\n",
    "    num_obs = int(dataset[\"counts\"].count_nonzero())\n",
    "    for step in range(num_steps):\n",
    "        loss = svi.step(dataset) / num_obs\n",
    "        series[\"loss\"].append(loss)\n",
    "        median = guide.median()  # cheap for autoguides\n",
    "        for name, value in median.items():\n",
    "            if value.numel() == 1:\n",
    "                series[name + \" mean\"].append(float(value))\n",
    "        if step % log_every == 0:\n",
    "            print(f\"step {step: >4d} loss = {loss:0.6g}\")\n",
    "\n",
    "    # Plot series to assess convergence.\n",
    "    if plot:\n",
    "        plt.figure(figsize=(6, 6))\n",
    "        for name, Y in series.items():\n",
    "            if name == \"loss\":\n",
    "                plt.plot(Y, \"k--\", label=name, zorder=0)\n",
    "            elif name.endswith(\" mean\"):\n",
    "                plt.plot(Y, label=name, zorder=-1)\n",
    "            else:\n",
    "                plt.plot(Y, label=name, alpha=0.5, lw=1, zorder=-2)\n",
    "        plt.xlabel(\"SVI step\")\n",
    "        plt.title(\"loss, scalar parameters, and gradient norms\")\n",
    "        plt.yscale(\"log\")\n",
    "        plt.xscale(\"symlog\")\n",
    "        plt.xlim(0, None)\n",
    "        plt.legend(loc=\"best\", fontsize=8)\n",
    "        plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "-z-UBawaKM3w"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "guide = AutoNormal(model, init_scale=0.01)\n",
    "fit_svi(model, guide)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8CB2cHfbKM3w"
   },
   "source": [
    "After each change to the model or inference, you'll validate model outputs, completing [Box's loop](http://www.cs.columbia.edu/~blei/papers/Blei2014b.pdf). In our running example we'll quantitiatively evaluate using the mean average error (MAE) over the last fully-observed time step."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "jzIoMBXfKM3w"
   },
   "outputs": [],
   "source": [
    "def mae(true_counts, pred_probs):\n",
    "    \"\"\"Computes mean average error between counts and predicted probabilities.\"\"\"\n",
    "    pred_counts = pred_probs * true_counts.sum(-1, True)\n",
    "    error = (true_counts - pred_counts).abs().sum(-1)\n",
    "    total = true_counts.sum(-1).clamp(min=1)\n",
    "    return (error / total).mean().item()\n",
    "\n",
    "def evaluate(\n",
    "    model, guide, num_particles=100, location=\"USA / Massachusetts\", time=-2\n",
    "):\n",
    "    if smoke_test:\n",
    "        num_particles = 4\n",
    "    \"\"\"Evaluate posterior predictive accuracy at the last fully observed time step.\"\"\"\n",
    "    with torch.no_grad(), poutine.mask(mask=False):  # makes computations cheaper\n",
    "        with pyro.plate(\"particle\", num_particles, dim=-3):  # vectorizes\n",
    "            guide_trace = poutine.trace(guide).get_trace(dataset)\n",
    "            probs = poutine.replay(model, guide_trace)(dataset, predict=time)\n",
    "        probs = probs.squeeze().mean(0)  # average over Monte Carlo samples\n",
    "        true_counts = dataset[\"counts\"][time]\n",
    "        # Compute global and local KL divergence.\n",
    "        global_mae = mae(true_counts, probs)\n",
    "        i = dataset[\"locations\"].index(location)\n",
    "        local_mae = mae(true_counts[i], probs[i])\n",
    "        return {\"MAE (global)\": global_mae, f\"MAE ({location})\": local_mae}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "LVhNFPu4KM3x"
   },
   "outputs": [],
   "source": [
    "pprint(evaluate(model, guide))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "fj--86jAYzN6"
   },
   "source": [
    "We'll also qualitatively evaluate using a volcano plot showing the effect size and statistical significance of each mutation's coefficient, and labeling the mutation with the most significant positive effect. We expect:\n",
    "- most mutations have very little effect (1.0)\n",
    "- more mutations have positive effect than netagive effect\n",
    "- effect sizes are on the order of 1.1 or 0.9."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "wgQMV_DpKM3x"
   },
   "outputs": [],
   "source": [
    "def plot_volcano(guide, num_particles=100):\n",
    "    if smoke_test:\n",
    "        num_particles = 4\n",
    "    with torch.no_grad(), poutine.mask(mask=False):  # makes computations cheaper\n",
    "        with pyro.plate(\"particle\", num_particles, dim=-3):  # vectorizes\n",
    "            trace = poutine.trace(guide).get_trace(dataset)\n",
    "            trace = poutine.trace(poutine.replay(model, trace)).get_trace(dataset, -1)\n",
    "            coef = trace.nodes[\"coef\"][\"value\"].cpu()\n",
    "    coef = coef.squeeze() * 0.01\n",
    "    mean = coef.mean(0)\n",
    "    std = coef.std(0)\n",
    "    z_score = mean.abs() / std\n",
    "    effect_size = mean.exp().numpy()\n",
    "    plt.figure(figsize=(6, 3))\n",
    "    plt.scatter(effect_size, z_score.numpy(), lw=0, s=5, alpha=0.5, color=\"darkred\")\n",
    "    plt.yscale(\"symlog\")\n",
    "    plt.xscale(\"log\")\n",
    "    plt.ylim(0, None)\n",
    "    plt.xlabel(\"$R_m/R_{wt}$\")\n",
    "    plt.ylabel(\"z-score\")\n",
    "    xticks = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3]\n",
    "    i = int((mean / std).max(0).indices)\n",
    "    plt.text(effect_size[i], z_score[i] * 1.1, dataset[\"mutations\"][i], ha=\"center\", fontsize=8)\n",
    "    plt.xticks(xticks, labels=list(map(str, xticks)))\n",
    "    plt.title(f\"Volcano plot of {len(mean)} mutations\")\n",
    "\n",
    "plot_volcano(guide)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "5MY99Q-zKM3x"
   },
   "source": [
    "## Create an initialization heuristic\n",
    "\n",
    "In high-dimensional models, convergence can be slow and NANs arise easily, even when sampling from [weakly informative priors](http://www.stat.columbia.edu/~gelman/presentations/weakpriorstalk.pdf). We recommend heuristically initializing a point estimate for each latent variable, aiming to initialize at something that is the right order of magnitude. Often you can initialize to a simple statistic of the data, e.g. a mean or standard deviation.\n",
    "\n",
    "Pyro's autoguides provide a number of [initialization strategies]() for initialzing the location parameter of many variational families, specified as `init_loc_fn`. You can create a custom initializer by accepting a pyro sample site dict and generating a sample from `site[\"name\"]` and `site[\"fn\"]` using e.g. `site[\"fn\"].shape()`, `site[\"fn\"].support`, `site[\"fn\"].mean`, or sampling via `site[\"fn\"].sample()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "_PzZX6fKKM3x"
   },
   "outputs": [],
   "source": [
    "def init_loc_fn(site):\n",
    "    shape = site[\"fn\"].shape()\n",
    "    if site[\"name\"] == \"coef\":\n",
    "        return torch.randn(shape).sub_(0.5).mul(0.01)\n",
    "    if site[\"name\"] == \"init\":\n",
    "        # Heuristically initialize based on data.\n",
    "        return dataset[\"counts\"].mean(0).add(0.01).log()\n",
    "    return init_to_feasible(site)  # fallback"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zwlg9pV6KM3y"
   },
   "source": [
    "As you evolve a model, you'll add and remove and rename latent variables. We find it useful to require inits for all latent variables, add a message to remind yourself to udpate the `init_loc_fn` whenever the model changes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "rCZI0TMGKM3y"
   },
   "outputs": [],
   "source": [
    "def init_loc_fn(site):\n",
    "    shape = site[\"fn\"].shape()\n",
    "    if site[\"name\"].endswith(\"_scale\"):\n",
    "        return torch.ones(shape)\n",
    "    if site[\"name\"] == \"coef\":\n",
    "        return torch.randn(shape).sub_(0.5).mul(0.01)\n",
    "    if site[\"name\"] == \"rate\":\n",
    "        return torch.zeros(shape)\n",
    "    if site[\"name\"] == \"init\":\n",
    "        return dataset[\"counts\"].mean(0).add(0.01).log()\n",
    "    raise NotImplementedError(f\"TODO initialize latent variable {site['name']}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "gxbVyvhnKM3y"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "guide = AutoNormal(model, init_loc_fn=init_loc_fn, init_scale=0.01)\n",
    "fit_svi(model, guide)\n",
    "pprint(evaluate(model, guide))\n",
    "plot_volcano(guide)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "pxeYvAlqKM3y"
   },
   "source": [
    "## Reparametrize the model\n",
    "\n",
    "Reparametrizing a model preserves its distribution while changing its geometry. Reparametrizing is simply a change of coordinates. When reparametrizing we aim to warp a model's geometry to remove correlations and to lift inconvenient topological manifolds into simpler higher dimensional flat Euclidean space.\n",
    "\n",
    "Whereas many probabilistic programming langauges require users to rewrite models to change coordinates, Pyro implements a library of about 15 different reparametrization effects including decentering (Gorinova et al. 2020), Haar wavely transforms, and neural transport (Hoffman et al. 2019), as well as strategies to automatically apply effects and machinery to create custom reparametrization effects. Using these reparametrizers you can separate modeling from inference: first specify a model in a form that is natural to domain experts, then in inference code, reparametrize the model to have geometry that is more amenable to variational inference."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "9Xuae9EEKM3y"
   },
   "source": [
    "In our SARS-CoV-2 model, the geometry might improve if we change\n",
    "```diff\n",
    "- rate = pyro.sample(\"rate\", dist.Normal(rate_loc, rate_scale))\n",
    "+ rate = pyro.sample(\"rate\", dist.Normal(0, 1)) * rate_scale + rate_loc\n",
    "```\n",
    "but that would make the model less interpretable. Instead we can reparametrize the model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "nct66uSCKM3y"
   },
   "outputs": [],
   "source": [
    "reparam_model = poutine.reparam(model, config={\"rate\": LocScaleReparam()})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Kx8Snxk2KM3y"
   },
   "source": [
    "or even automatically apply a set of recommended reparameterizers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "DEaRa83fKM3z"
   },
   "outputs": [],
   "source": [
    "reparam_model = AutoReparam()(model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "4M-04R17KM3z"
   },
   "source": [
    "Let's try reparametrizing both sites \"rate\" and \"init\". Note we'll create a fresh `reparam_model` each time we train a guide, since the parameters are stored in that `reparam_model` instance. Take care to use the `reparam_model` in downstream prediction tasks like running `evaluate(reparam_model, guide)`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "6s7Rfq6pKM3z"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "reparam_model = poutine.reparam(\n",
    "    model, {\"rate\": LocScaleReparam(), \"init\": LocScaleReparam()}\n",
    ")\n",
    "guide = AutoNormal(reparam_model, init_loc_fn=init_loc_fn, init_scale=0.01)\n",
    "fit_svi(reparam_model, guide)\n",
    "pprint(evaluate(reparam_model, guide))\n",
    "plot_volcano(guide)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "blr6l-GLKM3z"
   },
   "source": [
    "## Customize the variational family\n",
    "\n",
    "When creating a new model, we recommend starting with mean field variational inference using an [AutoNormal]() guide. This mean field guide is good at finding the neighborhood of your model's mode, but naively it ignores correlations between latent variables. A first step in capturing correlations is to reparametrize the model as above: using a `LocScaleReparam` or `HaarReparam` already allows the guide to capture some correlations among latent variables.\n",
    "\n",
    "The next step towards modeling uncertainty is to customize the variational family by trying other autoguides, building on [EasyGuide](), or creating a custom guide using Pyro primitives. We recommend increasing guide complexity gradually via these steps:\n",
    "1. Start with an [AutoNormal]() guide.\n",
    "2. Try [AutoLowRankMultivariateNormal](), which can model the principle components of correlated uncertainty. (For models with only ~100 latent variables you might also try [AutoMultivariateNormal]() or [AutoGaussian]()).\n",
    "3. Try combining multiple guides [AutoGuideList](). For example if [AutoLowRankMultivariateNormal]() is too expensive for all the latent variables, you can use [AutoGuideList]() to combine an [AutoLowRankMultivariateNormal]() guide over a few top-level global latent variables, together with a cheaper [AutoNormal]() guide over more numerous local latent variables.\n",
    "4. Try using [AutoGuideList]() to combine a autoguide together with a custom guide function built using `pyro.sample`, `pyro.param`, and `pyro.plate`. Given a `partial_guide()` function that covers just a few latent variables, you can `AutoGuideList.append(partial_guide)` just as you append autoguides.\n",
    "5. Consider customizing one of Pyro's autoguides that leverage model structure, e.g. [AutoStructured](https://docs.pyro.ai/en/latest/infer.autoguide.html#autostructured), [AutoNormalMessenger](https://docs.pyro.ai/en/latest/infer.autoguide.html#autonormalmessenger), [AutoHierarchicalNormalMessenger](https://docs.pyro.ai/en/latest/infer.autoguide.html#autohierarchicalnormalmessenger) [AutoRegressiveMessenger](https://docs.pyro.ai/en/latest/infer.autoguide.html#autoregressivemessenger).\n",
    "6. For models with local correlations, consider building on [EasyGuide](https://docs.pyro.ai/en/latest/contrib.easyguide.html), a framework for building guides over groups of variables.\n",
    "\n",
    "While a fully-custom guides built from `pyro.sample` primitives offer the most flexible variational family, they are also the most brittle guides because each code change to the model or reparametrizer requires changes in the guide. The author recommends avoiding completely low-level guides and instead using `AutoGuide` or `EasyGuide` for at least some parts of the model, thereby speeding up model iteration."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zgMSoFIVKM3z"
   },
   "source": [
    "Let's first try a simple `AutoLowRankMultivariateNormal` guide."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "btrEBvoCKM3z"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "reparam_model = poutine.reparam(\n",
    "    model, {\"rate\": LocScaleReparam(), \"init\": LocScaleReparam()}\n",
    ")\n",
    "guide = AutoLowRankMultivariateNormal(\n",
    "    reparam_model, init_loc_fn=init_loc_fn, init_scale=0.01, rank=100\n",
    ")\n",
    "fit_svi(reparam_model, guide, num_steps=10, log_every=1, plot=False)\n",
    "# don't even bother to evaluate, since this is too slow."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "BK3kgjhMT6ce"
   },
   "source": [
    "Yikes! This is quite slow and sometimes runs out of memory on GPU.\n",
    "\n",
    "Let's make this cheaper by using `AutoGuideList` to combine an `AutoLowRankMultivariateNormal` guide over the most important variables `rate_scale`, `init_scale`, and `coef`, together with a simple cheap `AutoNormal` guide on the rest of the model (the expensive `rate` and `init` variables). The typical pattern is to create two views of the model with [poutine.block](https://docs.pyro.ai/en/stable/poutine.html#pyro.poutine.handlers.block), one exposing the target variables and the other hiding them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "_jjmgrMqTu0w"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "reparam_model = poutine.reparam(\n",
    "    model, {\"rate\": LocScaleReparam(), \"init\": LocScaleReparam()}\n",
    ")\n",
    "guide = AutoGuideList(reparam_model)\n",
    "mvn_vars = [\"coef\", \"rate_scale\", \"coef_scale\"]\n",
    "guide.add(\n",
    "    AutoLowRankMultivariateNormal(\n",
    "        poutine.block(reparam_model, expose=mvn_vars),\n",
    "        init_loc_fn=init_loc_fn,\n",
    "        init_scale=0.01,\n",
    "    )\n",
    ")\n",
    "guide.add(\n",
    "    AutoNormal(\n",
    "        poutine.block(reparam_model, hide=mvn_vars),\n",
    "        init_loc_fn=init_loc_fn,\n",
    "        init_scale=0.01,\n",
    "    )\n",
    ")\n",
    "fit_svi(reparam_model, guide)\n",
    "pprint(evaluate(reparam_model, guide))\n",
    "plot_volcano(guide)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "o4TcrOWvgX_7"
   },
   "source": [
    "Next let's create a custom guide for part of the model, just the `rate` and `init` parts. Since we'll want to use this with reparametrizers, we'll make the guide use the auxiliary latent variables created by `poutine.reparam`, rather than the original `rate` and `init` variables. Let's see what these variables are named:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ole0UzqnWY37"
   },
   "outputs": [],
   "source": [
    "for name, site in poutine.trace(reparam_model).get_trace(\n",
    "    dataset\n",
    ").iter_stochastic_nodes():\n",
    "    print(name)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "7lkacduNmnmu"
   },
   "source": [
    "It looks like these new auxiliary variables are called `rate_decentered` and `init_decentered`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "r5b8-WbUibg2"
   },
   "outputs": [],
   "source": [
    "def local_guide(dataset):\n",
    "    # Create learnable parameters.\n",
    "    T, P, S = dataset[\"counts\"].shape\n",
    "    r_loc = pyro.param(\"rate_decentered_loc\", lambda: torch.zeros(P, S))\n",
    "    i_loc = pyro.param(\"init_decentered_loc\", lambda: torch.zeros(P, S))\n",
    "    skew = pyro.param(\"skew\", lambda: torch.zeros(P, S))  # allows correlation\n",
    "    r_scale = pyro.param(\"rate_decentered_scale\", lambda: torch.ones(P, S),\n",
    "                          constraint=constraints.softplus_positive)\n",
    "    i_scale = pyro.param(\"init_decentered_scale\", lambda: torch.ones(P, S),\n",
    "                          constraint=constraints.softplus_positive)\n",
    "\n",
    "    # Sample local variables inside plates.\n",
    "    # Note plates are already created by the main guide, so we'll\n",
    "    # use the existing plates rather than calling pyro.plate(...).\n",
    "    with guide.plates[\"place\"], guide.plates[\"strain\"]:\n",
    "        samples = {}\n",
    "        samples[\"rate_decentered\"] = pyro.sample(\n",
    "            \"rate_decentered\", dist.Normal(r_loc, r_scale)\n",
    "        )\n",
    "        i_loc = i_loc + skew * samples[\"rate_decentered\"]\n",
    "        samples[\"init_decentered\"] = pyro.sample(\n",
    "            \"init_decentered\", dist.Normal(i_loc, i_scale)\n",
    "        )\n",
    "    return samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Muz3PsZ0k9az"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "reparam_model = poutine.reparam(\n",
    "    model, {\"rate\": LocScaleReparam(), \"init\": LocScaleReparam()}\n",
    ")\n",
    "guide = AutoGuideList(reparam_model)\n",
    "local_vars = [\"rate_decentered\", \"init_decentered\"]\n",
    "guide.add(\n",
    "    AutoLowRankMultivariateNormal(\n",
    "        poutine.block(reparam_model, hide=local_vars),\n",
    "        init_loc_fn=init_loc_fn,\n",
    "        init_scale=0.01,\n",
    "    )\n",
    ")\n",
    "guide.add(local_guide)\n",
    "fit_svi(reparam_model, guide)\n",
    "pprint(evaluate(reparam_model, guide))\n",
    "plot_volcano(guide)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eeVU75KDlICi"
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "name": "workflow.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
