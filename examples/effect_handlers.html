<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Pyro Tutorials 1.8.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/pyro.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="&lt;no title&gt;" href="contrib_funsor_intro_i.html" />
    <link rel="prev" title="Mini-Pyro" href="minipyro.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/pyro_logo_wide.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.8.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Practical Pyro and PyTorch</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="svi_horovod.html">Example: distributed training via Horovod</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deep Generative Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cevae.html">Example: Causal Effect VAE</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparse_gamma.html">Example: Sparse Gamma Deep Exponential Family</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discrete Latent Variables</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="toy_mixture_model_discrete_enumeration.html">Example: Toy Mixture Model With Discrete Enumeration</a></li>
<li class="toctree-l1"><a class="reference internal" href="hmm.html">Example: Hidden Markov Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="capture_recapture.html">Example: Capture-Recapture Models (CJS Models)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixed_hmm.html">Example: hierarchical mixed-effect hidden Markov models</a></li>
<li class="toctree-l1"><a class="reference internal" href="einsum.html">Example: Discrete Factor Graph Inference with Plated Einsum</a></li>
<li class="toctree-l1"><a class="reference internal" href="lda.html">Example: Amortized Latent Dirichlet Allocation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Customizing Inference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="neutra.html">Example: Neural MCMC with NeuTraReparam</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparse_regression.html">Example: Sparse Bayesian Linear Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoname_examples.html">Example: reducing boilerplate with <code class="docutils literal notranslate"><span class="pre">pyro.contrib.autoname</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application: Time Series</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="forecast_simple.html">Multivariate Forecasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="timeseries.html">Example: Gaussian Process Time Series Models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application: Gaussian Processes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="dkl.html">Example: Deep Kernel Learning</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application: Epidemiology</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="epi_sir.html">Example: Univariate epidemiological models</a></li>
<li class="toctree-l1"><a class="reference internal" href="epi_regional.html">Example: Regional epidemiological models</a></li>
<li class="toctree-l1"><a class="reference internal" href="sir_hmc.html">Example: Epidemiological inference via HMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application: Biological sequences</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mue_profile.html">Example: Constant + MuE (Profile HMM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mue_factor.html">Example: Probabilistic PCA + MuE (FactorMuE)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Inference Algorithms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="baseball.html">Example: analyzing baseball stats with MCMC</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcmc.html">Example: Inference with Markov Chain Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="lkj.html">Example: MCMC with an LKJ prior over covariances</a></li>
<li class="toctree-l1"><a class="reference internal" href="smcfilter.html">Example: Sequential Monte Carlo Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="inclined_plane.html">Example: importance sampling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Understanding Pyro's Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="minipyro.html">Mini-Pyro</a></li>
<li class="toctree-l1"><a class="reference internal" href="hmm_funsor.html">Example: hidden Markov models with <code class="docutils literal notranslate"><span class="pre">pyro.contrib.funsor</span></code> and <code class="docutils literal notranslate"><span class="pre">pyroapi</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pyro Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/effect_handlers.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<dl>
<dt>{</dt><dd><dl>
<dt>“cells”: [</dt><dd><dl>
<dt>{</dt><dd><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“# Poutine: A Guide to Programming with Effect Handlers in Pyron”,
“n”,
“<strong>Note to readers</strong>: This tutorial is a guide to the API details of Pyro’s effect handling library, [Poutine](<a class="reference external" href="http://docs.pyro.ai/en/dev/poutine.html">http://docs.pyro.ai/en/dev/poutine.html</a>). We recommend readers first orient themselves with the simplified [minipyro.py](<a class="reference external" href="https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py">https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py</a>) which contains a minimal, readable implementation of Pyro’s runtime and the effect handler abstraction described here. Pyro’s effect handler library is more general than minipyro’s but also contains more layers of indirection; it helps to read them side-by-side.”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 1,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“import torchn”,
“n”,
“import pyron”,
“import pyro.distributions as distn”,
“import pyro.poutine as poutinen”,
“n”,
“from pyro.poutine.runtime import effectfuln”,
“n”,
“pyro.set_rng_seed(101)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Introductionn”,
“n”,
“Inference in probabilistic programming involves manipulating or transforming probabilistic programs written as generative models. For example, nearly all approximate inference algorithms require computing the unnormalized joint probability of values of latent and observed variables under a generative model.n”,
“n”,
“Consider the following example model:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 2,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def scale(guess):n”,
”    weight = pyro.sample(&quot;weight&quot;, dist.Normal(guess, 1.0))n”,
”    return pyro.sample(&quot;measurement&quot;, dist.Normal(weight, 0.75))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“This model defines a joint probability distribution over <cite>&quot;weight&quot;</cite> and <cite>&quot;measurement&quot;</cite>:n”,
“n”,
“$${\sf weight} \, | \, {\sf guess} \sim \cal {\sf Normal}({\sf guess}, 1) $$n”,
“$${\sf measurement} \, | \, {\sf guess}, {\sf weight} \sim {\sf Normal}({\sf weight}, 0.75)$$n”,
“n”,
“If we had access to the inputs and outputs of each <cite>pyro.sample</cite> site, we could compute their log-joint:n”,
“<code class="docutils literal notranslate"><span class="pre">`python\n&quot;,</span>
<span class="pre">&quot;logp</span> <span class="pre">=</span> <span class="pre">dist.Normal(guess,</span> <span class="pre">1.0).log_prob(weight).sum()</span> <span class="pre">+</span> <span class="pre">dist.Normal(weight,</span> <span class="pre">0.75).log_prob(measurement).sum()\n&quot;,</span>
<span class="pre">&quot;`</span></code>n”,
“However, the way we wrote <cite>scale</cite> above does not seem to expose these intermediate distribution objects, and rewriting it to return them would be intrusive and would violate the separation of concerns between models and inference algorithms that a probabilistic programming language like Pyro is designed to enforce.n”,
“n”,
“To resolve this conflict and facilitate inference algorithm development, Pyro exposes [Poutine](<a class="reference external" href="http://docs.pyro.ai/en/dev/poutine.html">http://docs.pyro.ai/en/dev/poutine.html</a>), a library of <em>effect handlers</em>, or composable building blocks for examining and modifying the behavior of Pyro programs. Most of Pyro’s internals are implemented on top of Poutine.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## A first look at Poutine: Pyro’s library of algorithmic building blocksn”,
“n”,
“Effect handlers, a common abstraction in the programming languages community, give <em>nonstandard interpretations</em> or <em>side effects</em> to the behavior of particular statements in a programming language, like <cite>pyro.sample</cite> or <cite>pyro.param</cite>. For background reading on effect handlers in programming language research, see the optional &quot;References&quot; section at the end of this tutorial. n”,
“n”,
“Rather than reviewing more definitions, let’s look at a first example that addresses the problem above: we can compose two existing effect handlers, <cite>poutine.condition</cite> (which sets output values of <cite>pyro.sample</cite> statements) and <cite>poutine.trace</cite> (which records the inputs, distributions, and outputs of <cite>pyro.sample</cite> statements), to concisely define a new effect handler that computes the log-joint:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 3,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“tensor(-3.0203)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“def make_log_joint(model):n”,
”    def _log_joint(cond_data, <a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs):n”,
”        conditioned_model = poutine.condition(model, data=cond_data)n”,
”        trace = poutine.trace(conditioned_model).get_trace(<a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs)n”,
”        return trace.log_prob_sum()n”,
”    return _log_jointn”,
“n”,
“scale_log_joint = make_log_joint(scale)n”,
“print(scale_log_joint({&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23}, 8.5))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“That snippet is short, but still somewhat opaque - <cite>poutine.condition</cite>, <cite>poutine.trace</cite>, and <cite>trace.log_prob_sum</cite> are all black boxes.  Let’s remove a layer of boilerplate from <cite>poutine.condition</cite> and <cite>poutine.trace</cite> and explicitly implement what <cite>trace.log_prob_sum</cite> is doing:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 4,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“tensor(-3.0203)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“from pyro.poutine.trace_messenger import TraceMessengern”,
“from pyro.poutine.condition_messenger import ConditionMessengern”,
“n”,
“def make_log_joint_2(model):n”,
”    def _log_joint(cond_data, <a href="#id9"><span class="problematic" id="id10">*</span></a>args, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):n”,
”        with TraceMessenger() as tracer:n”,
”            with ConditionMessenger(data=cond_data):n”,
”                model(<a href="#id13"><span class="problematic" id="id14">*</span></a>args, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs)n”,
”        n”,
”        trace = tracer.tracen”,
”        logp = 0.n”,
”        for name, node in trace.nodes.items():n”,
”            if node[&quot;type&quot;] == &quot;sample&quot;:n”,
”                if node[&quot;is_observed&quot;]:n”,
”                    assert node[&quot;value&quot;] is cond_data[name]n”,
”                logp = logp + node[&quot;fn&quot;].log_prob(node[&quot;value&quot;]).sum()n”,
”        return logpn”,
”    return _log_jointn”,
“n”,
“scale_log_joint = make_log_joint_2(scale)n”,
“print(scale_log_joint({&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23}, 8.5))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“This makes things a little more clear: we can now see that <cite>poutine.trace</cite> and <cite>poutine.condition</cite> are wrappers for context managers that presumably communicate with the model through something inside <cite>pyro.sample</cite>. We can also see that <cite>poutine.trace</cite>  produces a data structure (a [Trace](<a class="reference external" href="http://docs.pyro.ai/en/dev/poutine.html#trace">http://docs.pyro.ai/en/dev/poutine.html#trace</a>)) containing a dictionary whose keys are <cite>sample</cite> site names and values are dictionaries containing the distribution (<cite>&quot;fn&quot;</cite>) and output (<cite>&quot;value&quot;</cite>) at each site, and that the output values at each site are exactly the values specified in <cite>data</cite>.n”,
“n”,
“Finally, <cite>TraceMessenger</cite> and <cite>ConditionMessenger</cite> are Pyro effect handlers, or <cite>Messenger`s: stateful context manager objects that are placed on a global stack and send messages (hence the name) up and down the stack at each effectful operation, like a `pyro.sample</cite> call.  A <cite>Messenger</cite> is placed at the bottom of the stack when its <cite>__enter__</cite> method is called, i.e. when it is used in a &quot;with&quot; statement.n”,
“n”,
“We’ll look at this process in more detail later in this tutorial.  For a simplified implementation in only a few lines of code, see [pyro.contrib.minipyro](<a class="reference external" href="https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py">https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py</a>).”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Implementing new effect handlers with the <cite>Messenger</cite> APIn”,
“n”,
“Although it’s easiest to build new effect handlers by composing the existing ones in <cite>pyro.poutine</cite>, implementing a new effect as a <cite>pyro.poutine.messenger.Messenger</cite> subclass is actually fairly straightforward. Before diving into the API, let’s look at another example: a version of our log-joint computation that performs the sum while the model is executing. We’ll then review what each part of the example is actually doing.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 5,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“tensor(-3.0203)n”,
“tensor(-3.0203)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“class LogJointMessenger(poutine.messenger.Messenger):n”,
”    n”,
”    def __init__(self, cond_data):n”,
”        self.data = cond_datan”,
”    n”,
”    # __call__ is syntactic sugar for using Messengers as higher-order functions.n”,
”    # Messenger already defines __call__, but we re-define it heren”,
”    # for exposition and to change the return value:n”,
”    def __call__(self, fn):n”,
”        def _fn(<a href="#id17"><span class="problematic" id="id18">*</span></a>args, <a href="#id19"><span class="problematic" id="id20">**</span></a>kwargs):n”,
”            with self:n”,
”                fn(<a href="#id21"><span class="problematic" id="id22">*</span></a>args, <a href="#id23"><span class="problematic" id="id24">**</span></a>kwargs)n”,
”                return self.logp.clone()n”,
”        return _fnn”,
”    n”,
”    def __enter__(self):n”,
”        self.logp = torch.tensor(0.)n”,
”        # All Messenger subclasses must call the base Messenger.__enter__()n”,
”        # in their __enter__ methodsn”,
”        return super().__enter__()n”,
”    n”,
”    # __exit__ takes the same arguments in all Python context managersn”,
”    def __exit__(self, exc_type, exc_value, traceback):n”,
”        self.logp = torch.tensor(0.)n”,
”        # All Messenger subclasses must call the base Messenger.__exit__ methodn”,
”        # in their __exit__ methods.n”,
”        return super().__exit__(exc_type, exc_value, traceback)n”,
”    n”,
”    # _pyro_sample will be called once per pyro.sample site.n”,
”    # It takes a dictionary msg containing the name, distribution,n”,
”    # observation or sample value, and other metadata from the sample site.n”,
”    def _pyro_sample(self, msg):n”,
”        # Any unobserved random variables will trigger this assertion.n”,
”        # In the next section, we’ll learn how to also handle sampled values.n”,
”        assert msg[&quot;name&quot;] in self.datan”,
”        msg[&quot;value&quot;] = self.data[msg[&quot;name&quot;]]n”,
”        # Since we’ve observed a value for this site, we set the &quot;is_observed&quot; flag to Truen”,
”        # This tells any other Messengers not to overwrite msg[&quot;value&quot;] with a sample.n”,
”        msg[&quot;is_observed&quot;] = Truen”,
”        self.logp = self.logp + (msg[&quot;scale&quot;] * msg[&quot;fn&quot;].log_prob(msg[&quot;value&quot;])).sum()n”,
“n”,
“with LogJointMessenger(cond_data={&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23}) as m:n”,
”    scale(8.5)n”,
”    print(m.logp.clone())n”,
”    n”,
“scale_log_joint = LogJointMessenger(cond_data={&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23})(scale)n”,
“print(scale_log_joint(8.5))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“A convenient bit of boilerplate that allows the use of <cite>LogJointMessenger</cite> as a context manager, decorator, or higher-order function is the following.  Most of the existing effect handlers in <cite>pyro.poutine</cite>, including <cite>poutine.trace</cite> and <cite>poutine.condition</cite> which we used earlier, are <cite>Messenger`s wrapped this way in `pyro.poutine.handlers</cite>.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 6,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“tensor(-3.0203)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“def log_joint(model=None, cond_data=None):n”,
”    msngr = LogJointMessenger(cond_data=cond_data)n”,
”    return msngr(model) if model is not None else msngrn”,
“n”,
“scale_log_joint = log_joint(scale, cond_data={&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23})n”,
“print(scale_log_joint(8.5))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## The <cite>Messenger</cite> API in more detailn”,
“n”,
“Our <cite>LogJointMessenger</cite> implementation has three important methods: <cite>__enter__</cite>, <cite>__exit__</cite>, and <cite>_pyro_sample</cite>. n”,
“n”,
“<cite>__enter__</cite> and <cite>__exit__</cite> are special methods needed by any Python context manager. When implementing new <cite>Messenger</cite> classes, if we override <cite>__enter__</cite> and <cite>__exit__</cite>, we always need to call the base <cite>Messenger</cite>’s <cite>__enter__</cite> and <cite>__exit__</cite> methods for the new <cite>Messenger</cite> to be applied correctly.n”,
“n”,
“The last method <cite>LogJointMessenger._pyro_sample</cite>, is called once at each sample site. It reads and modifies a <em>message</em>, which is a dictionary containing the sample site’s name, distribution, sampled or observed value, and other metadata. We’ll examine the contents of a message in more detail in the next section.n”,
“n”,
“Instead of <cite>_pyro_sample</cite>, a generic <cite>Messenger</cite> actually contains two methods that are called once per operation where side effects are performed:n”,
“1. <cite>_process_message</cite> modifies a message and sends the result to the <cite>Messenger</cite> just above on the stackn”,
“2. <cite>_postprocess_message</cite> modifies a message and sends the result to the next <cite>Messenger</cite> down on the stack. It is always called after all active <cite>Messenger`s have had their `_process_message</cite> method applied to the message.n”,
“n”,
“Although custom <cite>Messenger`s can override `_process_message</cite> and <cite>_postprocess_message</cite>, it’s convenient to avoid requiring all effect handlers to be aware of all possible effectful operation types. For this reason, by default <cite>Messenger._process_message</cite> will use <cite>msg[&quot;type&quot;]</cite> to dispatch to a corresponding method <cite>Messenger._pyro_&lt;type&gt;</cite>, e.g. <cite>Messenger._pyro_sample</cite> as in <cite>LogJointMessenger</cite>.  Just as exception handling code ignores unhandled exception types, this allows <cite>Messenger`s to simply forward operations they don’t know how to handle up to the next `Messenger</cite> in the stack:n”,
“<code class="docutils literal notranslate"><span class="pre">`python\n&quot;,</span>
<span class="pre">&quot;class</span> <span class="pre">Messenger:\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">def</span> <span class="pre">_process_message(self,</span> <span class="pre">msg):\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">method_name</span> <span class="pre">=</span> <span class="pre">\&quot;_pyro_{}\&quot;.format(msg[\&quot;type\&quot;])</span>&#160; <span class="pre">#</span> <span class="pre">e.g.</span> <span class="pre">_pyro_sample</span> <span class="pre">when</span> <span class="pre">msg[\&quot;type\&quot;]</span> <span class="pre">==</span> <span class="pre">\&quot;sample\&quot;\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">if</span> <span class="pre">hasattr(self,</span> <span class="pre">method_name):\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">getattr(self,</span> <span class="pre">method_name)(msg)\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;`</span></code>”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Interlude: the global <cite>Messenger</cite> stackn”,
“n”,
“See [pyro.contrib.minipyro](<a class="reference external" href="https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py">https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py</a>) for an end-to-end implementation of the mechanism in this section.n”,
“n”,
“The order in which <cite>Messenger`s are applied to an operation like a `pyro.sample</cite> statement is determined by the order in which their <cite>__enter__</cite> methods are called.  <cite>Messenger.__enter__</cite> appends a <cite>Messenger</cite> to the end (the bottom) of the global handler stack:n”,
“<code class="docutils literal notranslate"><span class="pre">`python\n&quot;,</span>
<span class="pre">&quot;class</span> <span class="pre">Messenger:\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">__enter__</span> <span class="pre">pushes</span> <span class="pre">a</span> <span class="pre">Messenger</span> <span class="pre">onto</span> <span class="pre">the</span> <span class="pre">stack\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">def</span> <span class="pre">__enter__(self):\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">_PYRO_STACK.append(self)\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">__exit__</span> <span class="pre">removes</span> <span class="pre">a</span> <span class="pre">Messenger</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">stack\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">def</span> <span class="pre">__exit__(self,</span> <span class="pre">...):\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">assert</span> <span class="pre">_PYRO_STACK[-1]</span> <span class="pre">is</span> <span class="pre">self\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">_PYRO_STACK.pop()\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;`</span></code>n”,
“n”,
“<cite>pyro.poutine.runtime.apply_stack</cite> then traverses the stack twice at each operation, first from bottom to top to apply each <cite>_process_message</cite> and then from top to bottom to apply each <cite>_postprocess_message</cite>:n”,
“<code class="docutils literal notranslate"><span class="pre">`python\n&quot;,</span>
<span class="pre">&quot;def</span> <span class="pre">apply_stack(msg):</span>&#160; <span class="pre">#</span> <span class="pre">simplified\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">for</span> <span class="pre">handler</span> <span class="pre">in</span> <span class="pre">reversed(_PYRO_STACK):\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">handler._process_message(msg)\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">default_process_message(msg)\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">for</span> <span class="pre">handler</span> <span class="pre">in</span> <span class="pre">_PYRO_STACK:\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">handler._postprocess_message(msg)</span> <span class="pre">\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">...\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">msg\n&quot;,</span>
<span class="pre">&quot;`</span></code>”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Returning to the <cite>LogJointMessenger</cite> examplen”,
“n”,
“The second method <cite>_postprocess_message</cite> is necessary because some effects can only be applied after all other effect handlers have had a chance to update the message once. In the case of <cite>LogJointMessenger</cite>, other effects, like enumeration, may modify a sample site’s value or distribution (<cite>msg[&quot;value&quot;]</cite> or <cite>msg[&quot;fn&quot;]</cite>), so we move the log-probability computation to a new method, <cite>_pyro_post_sample</cite>, which is called by <cite>_postprocess_message</cite> (via a dispatch mechanism like the one used by <cite>_process_message</cite>) at each <cite>sample</cite> site after all active handlers’ <cite>_pyro_sample</cite> methods have been applied:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 7,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“tensor(-3.0203)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“class LogJointMessenger2(poutine.messenger.Messenger):n”,
”    n”,
”    def __init__(self, cond_data):n”,
”        self.data = cond_datan”,
”    n”,
”    def __call__(self, fn):n”,
”        def _fn(<a href="#id25"><span class="problematic" id="id26">*</span></a>args, <a href="#id27"><span class="problematic" id="id28">**</span></a>kwargs):n”,
”            with self:n”,
”                fn(<a href="#id29"><span class="problematic" id="id30">*</span></a>args, <a href="#id31"><span class="problematic" id="id32">**</span></a>kwargs)n”,
”                return self.logp.clone()n”,
”        return _fnn”,
”    n”,
”    def __enter__(self):n”,
”        self.logp = torch.tensor(0.)n”,
”        return super().__enter__()n”,
”    n”,
”    def __exit__(self, exc_type, exc_value, traceback):n”,
”        self.logp = torch.tensor(0.)n”,
”        return super().__exit__(exc_type, exc_value, traceback)n”,
“n”,
”    def _pyro_sample(self, msg):n”,
”        if msg[&quot;name&quot;] in self.data:n”,
”            msg[&quot;value&quot;] = self.data[msg[&quot;name&quot;]]n”,
”            msg[&quot;done&quot;] = Truen”,
”            n”,
”    def _pyro_post_sample(self, msg):n”,
”        assert msg[&quot;done&quot;]  # the &quot;done&quot; flag asserts that no more modifications to value and fn will be performed.n”,
”        self.logp = self.logp + (msg[&quot;scale&quot;] * msg[&quot;fn&quot;].log_prob(msg[&quot;value&quot;])).sum()n”,
“n”,
“n”,
“with LogJointMessenger2(cond_data={&quot;measurement&quot;: 9.5, &quot;weight&quot;: 8.23}) as m:n”,
”    scale(8.5)n”,
”    print(m.logp)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Inside the messages sent by <cite>Messenger`sn”,
“n”,
“As the previous two examples mentioned, the actual messages sent up and down the stack are dictionaries with a particular set of keys. Consider the following sample statement:n”,
“```pythonn”,
“pyro.sample(&quot;x&quot;, dist.Bernoulli(0.5), infer={&quot;enumerate&quot;: &quot;parallel&quot;}, obs=None)n”,
“``</cite>n”,
“This sample statement is converted into an initial message before any effects are applied, and each effect handler’s <cite>_process_message</cite> and <cite>_postprocess_message</cite> may update fields in place or add new fields.  We write out the full initial message here for completeness:n”,
“<code class="docutils literal notranslate"><span class="pre">`python\n&quot;,</span>
<span class="pre">&quot;msg</span> <span class="pre">=</span> <span class="pre">{\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">The</span> <span class="pre">following</span> <span class="pre">fields</span> <span class="pre">contain</span> <span class="pre">the</span> <span class="pre">name,</span> <span class="pre">inputs,</span> <span class="pre">function,</span> <span class="pre">and</span> <span class="pre">output</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">site.\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">These</span> <span class="pre">are</span> <span class="pre">generally</span> <span class="pre">the</span> <span class="pre">only</span> <span class="pre">fields</span> <span class="pre">you'll</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">think</span> <span class="pre">about.\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;name\&quot;:</span> <span class="pre">\&quot;x\&quot;,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;fn\&quot;:</span> <span class="pre">dist.Bernoulli(0.5),\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;value\&quot;:</span> <span class="pre">None,</span>&#160; <span class="pre">#</span> <span class="pre">msg[\&quot;value\&quot;]</span> <span class="pre">will</span> <span class="pre">eventually</span> <span class="pre">contain</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">returned</span> <span class="pre">by</span> <span class="pre">pyro.sample\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;is_observed\&quot;:</span> <span class="pre">False,</span>&#160; <span class="pre">#</span> <span class="pre">because</span> <span class="pre">obs=None</span> <span class="pre">by</span> <span class="pre">default;</span> <span class="pre">only</span> <span class="pre">used</span> <span class="pre">by</span> <span class="pre">sample</span> <span class="pre">sites\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;args\&quot;:</span> <span class="pre">(),</span>&#160; <span class="pre">#</span> <span class="pre">positional</span> <span class="pre">arguments</span> <span class="pre">passed</span> <span class="pre">to</span> <span class="pre">\&quot;fn\&quot;</span> <span class="pre">when</span> <span class="pre">it</span> <span class="pre">is</span> <span class="pre">called;</span> <span class="pre">usually</span> <span class="pre">empty</span> <span class="pre">for</span> <span class="pre">sample</span> <span class="pre">sites\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;kwargs\&quot;:</span> <span class="pre">{},</span>&#160; <span class="pre">#</span> <span class="pre">keyword</span> <span class="pre">arguments</span> <span class="pre">passed</span> <span class="pre">to</span> <span class="pre">\&quot;fn\&quot;</span> <span class="pre">when</span> <span class="pre">it</span> <span class="pre">is</span> <span class="pre">called;</span> <span class="pre">usually</span> <span class="pre">empty</span> <span class="pre">for</span> <span class="pre">sample</span> <span class="pre">sites\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">This</span> <span class="pre">field</span> <span class="pre">typically</span> <span class="pre">contains</span> <span class="pre">metadata</span> <span class="pre">needed</span> <span class="pre">or</span> <span class="pre">stored</span> <span class="pre">by</span> <span class="pre">a</span> <span class="pre">particular</span> <span class="pre">inference</span> <span class="pre">algorithm\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;infer\&quot;:</span> <span class="pre">{\&quot;enumerate\&quot;:</span> <span class="pre">\&quot;parallel\&quot;},\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">The</span> <span class="pre">remaining</span> <span class="pre">fields</span> <span class="pre">are</span> <span class="pre">generally</span> <span class="pre">only</span> <span class="pre">used</span> <span class="pre">by</span> <span class="pre">Pyro's</span> <span class="pre">internals,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">or</span> <span class="pre">for</span> <span class="pre">implementing</span> <span class="pre">more</span> <span class="pre">advanced</span> <span class="pre">effects</span> <span class="pre">beyond</span> <span class="pre">the</span> <span class="pre">scope</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">tutorial\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;type\&quot;:</span> <span class="pre">\&quot;sample\&quot;,</span>&#160; <span class="pre">#</span> <span class="pre">label</span> <span class="pre">used</span> <span class="pre">by</span> <span class="pre">Messenger._process_message</span> <span class="pre">to</span> <span class="pre">dispatch,</span> <span class="pre">in</span> <span class="pre">this</span> <span class="pre">case</span> <span class="pre">to</span> <span class="pre">_pyro_sample\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;done\&quot;:</span> <span class="pre">False,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;stop\&quot;:</span> <span class="pre">False,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;scale\&quot;:</span> <span class="pre">torch.tensor(1.),</span>&#160; <span class="pre">#</span> <span class="pre">Multiplicative</span> <span class="pre">scale</span> <span class="pre">factor</span> <span class="pre">that</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">applied</span> <span class="pre">to</span> <span class="pre">each</span> <span class="pre">site's</span> <span class="pre">log_prob\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;mask\&quot;:</span> <span class="pre">None,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;continuation\&quot;:</span> <span class="pre">None,\n&quot;,</span>
<span class="pre">&quot;</span>&#160;&#160;&#160; <span class="pre">\&quot;cond_indep_stack\&quot;:</span> <span class="pre">(),</span>&#160; <span class="pre">#</span> <span class="pre">Will</span> <span class="pre">contain</span> <span class="pre">metadata</span> <span class="pre">from</span> <span class="pre">each</span> <span class="pre">pyro.plate</span> <span class="pre">enclosing</span> <span class="pre">this</span> <span class="pre">sample</span> <span class="pre">site.\n&quot;,</span>
<span class="pre">&quot;}\n&quot;,</span>
<span class="pre">&quot;`</span></code>n”,
“Note that when we use <cite>poutine.trace</cite> or <cite>TraceMessenger</cite> as in our first two versions of <cite>make_log_joint</cite>, the contents of <cite>msg</cite> are exactly the information stored in the trace for each sample and param site.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Implementing inference algorithms with existing effect handlers: examplesn”,
“n”,
“It turns out that many inference operations, like our first version of <cite>make_log_joint</cite> above, have strikingly short implementations in terms of existing effect handlers in <cite>pyro.poutine</cite>. “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Example: Variational inference with a Monte Carlo ELBOn”,
“n”,
“For example, here is an implementation of variational inference with a Monte Carlo ELBO that uses <cite>poutine.trace</cite>, <cite>poutine.condition</cite>, and <cite>poutine.replay</cite>.  This is very similar to the simple ELBO in [pyro.contrib.minipyro](<a class="reference external" href="https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py">https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/minipyro.py</a>).”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 8,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def monte_carlo_elbo(model, guide, batch, <a href="#id33"><span class="problematic" id="id34">*</span></a>args, <a href="#id35"><span class="problematic" id="id36">**</span></a>kwargs):n”,
”    # assuming batch is a dictionary, we use poutine.condition to fix values of observed variablesn”,
”    conditioned_model = poutine.condition(model, data=batch)n”,
”    n”,
”    # we’ll approximate the expectation in the ELBO with a single sample:n”,
”    # first, we run the guide forward unmodified and record values and distributionsn”,
”    # at each sample site using poutine.tracen”,
”    guide_trace = poutine.trace(guide).get_trace(<a href="#id37"><span class="problematic" id="id38">*</span></a>args, <a href="#id39"><span class="problematic" id="id40">**</span></a>kwargs)n”,
”    n”,
”    # we use poutine.replay to set the values of latent variables in the modeln”,
”    # to the values sampled above by our guide, and use poutine.tracen”,
”    # to record the distributions that appear at each sample site in in the modeln”,
”    model_trace = poutine.trace(n”,
”        poutine.replay(conditioned_model, trace=guide_trace)n”,
”    ).get_trace(<a href="#id41"><span class="problematic" id="id42">*</span></a>args, <a href="#id43"><span class="problematic" id="id44">**</span></a>kwargs)n”,
”    n”,
”    elbo = 0.n”,
”    for name, node in model_trace.nodes.items():n”,
”        if node[&quot;type&quot;] == &quot;sample&quot;:n”,
”            elbo = elbo + node[&quot;fn&quot;].log_prob(node[&quot;value&quot;]).sum()n”,
”            if not node[&quot;is_observed&quot;]:n”,
”                elbo = elbo - guide_trace.nodes[name][&quot;fn&quot;].log_prob(node[&quot;value&quot;]).sum()n”,
”    return -elbo”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“We use <cite>poutine.trace</cite> and <cite>poutine.block</cite> to record <cite>pyro.param</cite> calls for optimization:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 9,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def train(model, guide, data):n”,
”    optimizer = pyro.optim.Adam({})n”,
”    for batch in <a class="reference external" href="data:n">data:n</a>”,
”        # this poutine.trace will record all of the parameters that appear in the model and guiden”,
”        # during the execution of monte_carlo_elbon”,
”        with poutine.trace() as param_capture:n”,
”            # we use poutine.block here so that only parameters appear in the trace aboven”,
”            with poutine.block(hide_fn=lambda node: node[&quot;type&quot;] != &quot;param&quot;):n”,
”                loss = monte_carlo_elbo(model, guide, batch)n”,
”        n”,
”        loss.backward()n”,
”        params = set(node[&quot;value&quot;].unconstrained()n”,
”                     for node in param_capture.trace.nodes.values())n”,
”        optimizer.step(params)n”,
”        pyro.infer.util.zero_grads(params)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Example: exact inference via sequential enumerationn”,
“n”,
“Here is an example of a very different inference algorithm–exact inference via enumeration–implemented with <cite>pyro.poutine</cite>.  A complete explanation of this algorithm is beyond the scope of this tutorial and may be found in Chapter 3 of the short online book [Design and Implementation of Probabilistic Programming Languages](<a class="reference external" href="http://dippl.org/chapters/03-enumeration.html">http://dippl.org/chapters/03-enumeration.html</a>).  This example uses <cite>poutine.queue</cite>, itself implemented using <cite>poutine.trace</cite>, <cite>poutine.replay</cite>, and <cite>poutine.block</cite>, to enumerate over possible values of all discrete variables in a model and compute a marginal distribution over all possible return values or the possible values at a particular sample site:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 10,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def sequential_discrete_marginal(model, data, site_name=&quot;_RETURN&quot;):n”,
”    n”,
”    from six.moves import queue  # queue data structuresn”,
”    q = queue.Queue()  # Instantiate a first-in first-out queuen”,
”    q.put(poutine.Trace())  # seed the queue with an empty tracen”,
”    n”,
”    # as before, we fix the values of observed random variables with poutine.conditionn”,
”    # assuming data is a dictionary whose keys are names of sample sites in modeln”,
”    conditioned_model = poutine.condition(model, data=data)n”,
”    n”,
”    # we wrap the conditioned model in a poutine.queue,n”,
”    # which repeatedly pushes and pops partially completed executions from a Queue()n”,
”    # to perform breadth-first enumeration over the set of values of all discrete sample sites in modeln”,
”    enum_model = poutine.queue(conditioned_model, queue=q)n”,
”    n”,
”    # actually perform the enumeration by repeatedly tracing enum_modeln”,
”    # and accumulate samples and trace log-probabilities for postprocessingn”,
”    samples, log_weights = [], []n”,
”    while not q.empty():n”,
”        trace = poutine.trace(enum_model).get_trace()n”,
”        samples.append(trace.nodes[site_name][&quot;value&quot;])n”,
”        log_weights.append(trace.log_prob_sum())n”,
”        n”,
”    # we take the samples and log-joints and turn them into a histogram:n”,
”    samples = torch.stack(samples, 0)n”,
”    log_weights = torch.stack(log_weights, 0)n”,
”    log_weights = log_weights - dist.util.logsumexp(log_weights, dim=0)n”,
”    return dist.Empirical(samples, log_weights)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“(Note that <cite>sequential_discrete_marginal</cite> is very general, but is also quite slow. For high-performance parallel enumeration that applies to a less general class of models, see the enumeration tutorial.)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Example: implementing lazy evaluation with the <cite>Messenger</cite> APIn”,
“n”,
“Now that we’ve learned more about the internals of <cite>Messenger</cite>, let’s use it to implement a slightly more complicated effect: lazy evaluation. We first define a <cite>LazyValue</cite> class that we will use to build up a computation graph:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 11,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“class LazyValue:n”,
”    def __init__(self, fn, <a href="#id45"><span class="problematic" id="id46">*</span></a>args, <a href="#id47"><span class="problematic" id="id48">**</span></a>kwargs):n”,
”        self._expr = (fn, args, kwargs)n”,
”        self._value = Nonen”,
”        n”,
”    def __str__(self):n”,
”        return &quot;({} {})&quot;.format(str(self._expr[0]), &quot; &quot;.join(map(str, self._expr[1])))n”,
”        n”,
”    def evaluate(self):n”,
”        if self._value is None:n”,
”            fn, args, kwargs = self._exprn”,
”            fn = fn.evaluate() if isinstance(fn, LazyValue) else fnn”,
”            args = tuple(arg.evaluate() if isinstance(arg, LazyValue) else argn”,
”                         for arg in args)n”,
”            kwargs = {k: v.evaluate() if isinstance(v, LazyValue) else vn”,
”                      for k, v in kwargs.items()}n”,
”            self._value = fn(<a href="#id49"><span class="problematic" id="id50">*</span></a>args, <a href="#id51"><span class="problematic" id="id52">**</span></a>kwargs)n”,
”        return self._value”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“With <cite>LazyValue</cite>, implementing lazy evaluation as a <cite>Messenger</cite> compatible with other effect handlers is suprisingly easy. We just make each <cite>msg[&quot;value&quot;]</cite> a <cite>LazyValue</cite> and introduce a new operation type <cite>&quot;apply&quot;</cite> for deterministic operations:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 12,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“class LazyMessenger(pyro.poutine.messenger.Messenger):n”,
”    def _process_message(self, msg):n”,
”        if msg[&quot;type&quot;] in (&quot;apply&quot;, &quot;sample&quot;) and not msg[&quot;done&quot;]:n”,
”            msg[&quot;done&quot;] = Truen”,
”            msg[&quot;value&quot;] = LazyValue(msg[&quot;fn&quot;], <a href="#id53"><span class="problematic" id="id54">*</span></a>msg[&quot;args&quot;], <a href="#id55"><span class="problematic" id="id56">**</span></a>msg[&quot;kwargs&quot;])”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Finally, just like <cite>torch.autograd</cite> overloads <cite>torch</cite> tensor operations to record an autograd graph, we need to wrap any operations we’d like to be lazy.  We’ll use <cite>pyro.poutine.runtime.effectful</cite> as a decorator to expose these operations to <cite>LazyMessenger</cite>. <cite>effectful</cite> constructs a message much like the one above and sends it up and down the effect handler stack, but allows us to set the type (in this case, to <cite>&quot;apply&quot;</cite> instead of <cite>&quot;sample&quot;</cite>) so that these operations aren’t mistaken for <cite>sample</cite> statements by other effect handlers like <cite>TraceMessenger</cite>:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 13,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“&#64;effectful(type=&quot;apply&quot;)n”,
“def add(x, y):n”,
”    return x + yn”,
“n”,
“&#64;effectful(type=&quot;apply&quot;)n”,
“def mul(x, y):n”,
”    return x * yn”,
“n”,
“&#64;effectful(type=&quot;apply&quot;)n”,
“def sigmoid(x):n”,
”    return torch.sigmoid(x)n”,
“n”,
“&#64;effectful(type=&quot;apply&quot;)n”,
“def normal(loc, scale):n”,
”    return dist.Normal(loc, scale)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Applied to another model:”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 14,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“((&lt;function normal at 0x7fc41cbfdc80&gt; (&lt;function add at 0x7fc41cbf91e0&gt; (&lt;function mul at 0x7fc41cbfda60&gt; ((&lt;function normal at 0x7fc41cbfdc80&gt; 8.5 1.0) ) 0.8) 1.0) (&lt;function sigmoid at 0x7fc41cbfdb70&gt; ((&lt;function normal at 0x7fc41cbfdc80&gt; 0.0 0.25) ))) )n”,
“tensor(6.5436)n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“def biased_scale(guess):n”,
”    weight = pyro.sample(&quot;weight&quot;, normal(guess, 1.))n”,
”    tolerance = pyro.sample(&quot;tolerance&quot;, normal(0., 0.25))n”,
”    return pyro.sample(&quot;measurement&quot;, normal(add(mul(weight, 0.8), 1.), sigmoid(tolerance)))n”,
“n”,
“with LazyMessenger():n”,
”    v = biased_scale(8.5)n”,
”    print(v)n”,
”    print(v.evaluate())”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Together with other effect handlers like <cite>TraceMessenger</cite> and <cite>ConditionMessenger</cite>, with which it freely composes, <cite>LazyMessenger</cite> demonstrates how to use Poutine to quickly and concisely implement state-of-the-art PPL techniques like [delayed sampling with Rao-Blackwellization](<a class="reference external" href="https://arxiv.org/abs/1708.07787">https://arxiv.org/abs/1708.07787</a>).”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## References: algebraic effects and handlers in programming language researchn”,
“n”,
“This section contains some references to PL papers for readers interested in this direction.n”,
“n”,
“Algebraic effects and handlers, which were developed starting in the early 2000s and are a subject of active research in the programming languages community, are a versatile abstraction for building modular implementations of nonstandard interpreters of particular statements in a programming language, like <cite>pyro.sample</cite> or <cite>pyro.param</cite>.  They were originally introduced to address the difficulty of composing nonstandard interpreters implemented with monads and monad transformers.n”,
“n”,
“- For an accessible introduction to the effect handlers literature, see the excellent review/tutorial paper [&quot;Handlers in Action&quot;](<a class="reference external" href="http://homepages.inf.ed.ac.uk/slindley/papers/handlers.pdf">http://homepages.inf.ed.ac.uk/slindley/papers/handlers.pdf</a>) by Ohad Kammar, Sam Lindley, and Nicolas Oury, and the references therein.n”,
“n”,
“- Algebraic effect handlers were originally introduced by Gordon Plotkin and Matija Pretnar in the paper [&quot;Handlers of Algebraic Effects&quot;](<a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-642-00590-9_7).n">https://link.springer.com/chapter/10.1007/978-3-642-00590-9_7).n</a>”,
“n”,
“- A useful mental model of effect handlers is as exception handlers that are capable of resuming computation in the <cite>try</cite> block after raising an exception and performing some processing in the <cite>except</cite> block. This metaphor is explored further in the experimental programming language [Eff](<a class="reference external" href="http://math.andrej.com/eff/">http://math.andrej.com/eff/</a>) and its companion paper [&quot;Programming with Algebraic Effects and Handlers&quot;](<a class="reference external" href="https://arxiv.org/abs/1203.1539">https://arxiv.org/abs/1203.1539</a>) by Andrej Bauer and Matija Pretnar.n”,
“n”,
“- Most effect handlers in Pyro are &quot;linear,&quot; meaning that they only resume once per effectful operation and do not alter the order of execution of the original program. One exception is <cite>poutine.queue</cite>, which uses an inefficient implementation strategy for multiple resumptions like the one described for delimited continuations in the paper [&quot;Capturing the Future by Replaying the Past&quot;](<a class="reference external" href="http://delivery.acm.org/10.1145/3240000/3236771/icfp18main-p36-p.pdf">http://delivery.acm.org/10.1145/3240000/3236771/icfp18main-p36-p.pdf</a>) by James Koppel, Gabriel Scherer, and Armando Solar-Lezama.  n”,
“n”,
“- More efficient implementation strategies for effect handlers in mainstream programming languages like Python or JavaScript is an area of active research. One promising line of work involves selective continuation-passing style transforms as in the paper [&quot;Type-Directed Compilation of Row-Typed Algebraic Effects&quot;](<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/algeff.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/algeff.pdf</a>) by Daan Leijen.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>],
“metadata”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“kernelspec”: {</dt><dd><p>“display_name”: “Python 3”,
“language”: “python”,
“name”: “python3”</p>
</dd>
</dl>
<p>},
“language_info”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“codemirror_mode”: {</dt><dd><p>“name”: “ipython”,
“version”: 3</p>
</dd>
</dl>
<p>},
“file_extension”: “.py”,
“mimetype”: “text/x-python”,
“name”: “python”,
“nbconvert_exporter”: “python”,
“pygments_lexer”: “ipython3”,
“version”: “3.6.10”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>},
“nbformat”: 4,
“nbformat_minor”: 2</p>
</dd>
</dl>
<p>}</p>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="minipyro.html" class="btn btn-neutral float-left" title="Mini-Pyro" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="contrib_funsor_intro_i.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Pyro Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>